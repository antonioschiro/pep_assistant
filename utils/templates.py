# Retrieved documents evaluator prompt
retrieved_document_template = '''You are an evaluator assessing whether a retrieved document is relevant to a piece of user code.

The document can be defined as **relevant** if it meets **at least one** of these condition:
- It contains one or more rules that you could apply to the user code.
- It contains one or more code snippets that demonstrate improvements or corrections applicable to the user code.

Reason explicitly about whether the retrieved document can be used for improve the user code.

Below are examples:

Example 1:
User code:
def custom_fun(a=3, l):
    O= 3*l
    return O

Document: 
Never use the characters ‘l’ (lowercase letter el), ‘O’ (uppercase letter oh), or ‘I’ (uppercase letter eye) as single character variable names.
In some fonts, these characters are indistinguishable from the numerals one and zero. When tempted to use ‘l’, use ‘L’ instead.

Reason:
The document is **relevant** because it highlights a naming issue directly present in the user code. 
-> {{"score": true}}

Example 2:
User code:
def split_line_func(text:str)->list:
    " This function takes in input the variable
    text and returns the splitted text"
    return text.split()

Document:
def kos_root():
    """Return the pathname of the KOS root directory."""
    global _kos_root
    if _kos_root: return _kos_root
    ...

Reason:
The document is **relevant** because it demonstrates the use of proper triple-quoted docstrings, which can be applied to the user code.
-> {{"score": true}}

Example 3:
User code:
class Car:
    def __init__(self, color, brand, engine):
        self.color = color
        self.brand = brand
        self.engine = engine

Document:
# Correct:
try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)
# Wrong:
try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)

Reason:
The document is **not relevant** because the user code does not involve exception handling. No applicable rule or snippet.
-> {{"score": false}}

Document:
{document}

User Code:
{code}

Respond **only** in the following JSON format:

- If document is relevant: {{"score": true}}
- If document is not relevant: {{"score": false}}'''

# Generating response prompt
generate_response_template = '''
You are a powerful Python code assistant.
Your goal is to make input code **compliant** to Python standards.

The code is considered **compliant** if **at least one** of the following conditions are met:
- the code is generated by applying on the input code the rules provided by PEP (Python Enhancement Proposal);
- the code is generated by applying the best practices derived by PEP examples on the input code;
- the code is generated by imitating, copy or learn from code snippets of the most well-written Python libraries.

Below are examples:

Example 1:
User input code:
def pretty_print_age(name: str, age:int):
    print(name.capitalize(), " is ", a, " years old.")

PEP rules and examples:
F-strings provide a way to embed expressions inside string literals, using a minimal syntax. 
It should be noted that an f-string is really an expression evaluated at run time, not a constant value. 
In Python source code, an f-string is a literal string, prefixed with ‘f’, which contains expressions inside braces. 
The expressions are replaced with their values. Some examples are:
import datetime
name = 'Fred'
age = 50
anniversary = datetime.date(1991, 10, 12)
f'My name is {{name}}, my age next year is {{age+1}}, my anniversary is {{anniversary:%A, %B %d, %Y}}.'
'My name is Fred, my age next year is 51, my anniversary is Saturday, October 12, 1991.'
f'He said his name is {{name!r}}.'
"He said his name is 'Fred'."

Output code:
def pretty_print_age(name: str, age:int):
    print(f"{{name.capitalize()}} is {{age}} years old.")

Reason:
The generated code is **compliant** because it implements an applicable PEP rule.

Example 2:
User input code:
def save_file(filename, content):
    path = Path.cwd()
    full_path = os.path.join(str(path), filename)
    with open(full_path, 'w') as f:
        f.write(content)

Code snippets from Python libraries:
app = Flask(__name__)
upload_folder = Path(app.root_path) / "uploads"
upload_folder.mkdir(exist_ok=True)
@app.route('/upload', methods=['POST'])
def upload_file():
    file = request.files['file']
    filename = secure_filename(file.filename)
    file_path = upload_folder / filename
    file.save(file_path)
    return f"File saved to {{file_path}}"

Output code:
def save_file(filename, content):
    full_path = Path.cwd() / filename
    with full_path.open('w') as f:
        f.write(content)

Reason:
The generated code is **compliant** because it fixes the following issues:
- Mixing os.path.join with pathlib instead of using pathlib's / operator or joinpath method;
- Converting Path object to string unnecessarily;
- Using the built-in open function instead of Path.open().

Example 3:
User input code:
file_path = Path("example.txt")
file = file_path.open("w")
file.write("Hello, Imperfect World!")
file.close()

PEP rules and examples:
with opened("/etc/passwd") as f:
    for line in f:
        print line.rstrip()

Code snippets from Python libraries:
log_errors = Path("logs.txt")
with log_errors.open("a") as file:
    file.write("Error code 1 occurred")

Output code:
file_path = Path("example.txt")
with file_path.open("w") as file:
    file.write("Hello, Imperfect World!")

Reason:
The input code has been improved by using jointly PEP documents and code snippets.
The generated code is **compliant** because:
- Automatically closes the file;
- It's safer, even if exceptions occur;
- It's concise and readable.
    
Here's the PEP rules and examples:
{rules}

Below you will find examples of well-written Pythonic code snippets from the most popular Python libraries:
{code_snippets}

You need to improve the user input code:
{code}

Think step by step about how to make the user code cleaner and pythonic using rules and code snippets provided.
Then, generate the improved code.
If you can't improve the user code because everything is fine or for any other reason, just respond by returning **only** the input code.
Otherwise, respond by returning **only** the improved code, without **any** additional string, information or markdown formatting.'''

# Potential hallucinations evaluator prompt
hallucinations_template = '''You are an evaluator assessing whether the generated code is hallucinated or not 
with respect to a given context.

Definitions:
- The code is **hallucinated** if it directly contradicts the context, introduces rules or patterns that are unsupported, or deviates significantly from provided guidance.
- The code is **grounded** if it is consistent with, inspired by, or reasonably aligned with any part of the context — even if not a perfect match.

Reason explicitly to decide whether the generated code is generally supported by the context or not.

Generated code:
{response}

Context (rules, style guide, examples):
{context}

Respond **only** in the following JSON format:
-If the response is hallucinated return: {{"score": true}}
-If the response is grounded return: {{"score": false}}'''

# Answers completeness evaluator prompt
completeness_template = '''You are an evaluator assessing the completeness of the generated code
with respect to the user input code.

The generated code is considered a complete answer if the following two conditions are met:
- the generated code is an efficient and pythonic version of the user input code.
- the generated code purpose is the same of the user input code.

Here is the generated code:
{response}

This is the user input code:
{code}

Reason explicitly about whether the generated code is a complete answer to the user input code.
Respond **only** in the following JSON format:
-If the response is complete return: {{"score": true}}
-If the response is incomplete return: {{"score": false}}
'''
# Retry generate. This template will be added to the generate response template in case of retrying.
retry_generate_template= '''
Note that you already generate a response for this user input code, but it is hallucinated.
Here's the hallucinated response:
{hallucinated_response}

Try to generate another response knowing that the previous one was not grounded.
'''