



PEP 604 – Allow writing union types as X | Y | peps.python.org






















Following system colour scheme






Selected dark colour scheme






Selected light colour scheme
















Python Enhancement Proposals

Python » 
PEP Index » 
PEP 604





Toggle light / dark / auto colour theme




PEP 604 – Allow writing union types as X | Y

Author:
Philippe PRADOS <python at prados.fr>, Maggie Moss <maggiebmoss at gmail.com>
Sponsor:
Chris Angelico <rosuav at gmail.com>
BDFL-Delegate:
Guido van Rossum <guido at python.org>
Discussions-To:
Typing-SIG list
Status:
Final
Type:
Standards Track
Topic:
Typing
Created:
28-Aug-2019
Python-Version:
3.10
Post-History:
28-Aug-2019, 05-Aug-2020



Table of Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright



Important
This PEP is a historical document. The up-to-date, canonical documentation can now be found at Union Type.
×
See PEP 1 for how to propose changes.


Abstract
This PEP proposes overloading the | operator on types to allow
writing Union[X, Y] as X | Y, and allows it to appear in
isinstance and issubclass calls.


Motivation
PEP 484 and PEP 526 propose a generic syntax to add typing to variables,
parameters and function returns. PEP 585 proposes to expose
parameters to generics at runtime.
Mypy [1] accepts a syntax which looks like:
annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']



To describe a disjunction (union type), the user must use Union[X, Y].

The verbosity of this syntax does not help with type adoption.


Proposal
Inspired by Scala [2] and Pike [3], this proposal adds operator
type.__or__().  With this new operator, it is possible to write
int | str instead of Union[int, str]. In addition to
annotations, the result of this expression would then be valid in
isinstance() and issubclass():
isinstance(5, int | str)
issubclass(bool, int | float)


We will also be able to write t | None or None | t instead of
Optional[t]:
isinstance(None, int | None)
isinstance(42, None | int)




Specification
The new union syntax should be accepted for function, variable and parameter annotations.

Simplified Syntax
# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]


The existing typing.Union and | syntax should be equivalent.
int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int


The order of the items in the Union should not matter for equality.
(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]


Optional values should be equivalent to the new union syntax
None | t == typing.Optional[t]


A new Union.__repr__() method should be implemented.
str(int | list[str])
# int | list[str]

str(int | int)
# int




isinstance and issubclass
The new syntax should be accepted for calls to isinstance and issubclass as long as the Union items are valid arguments to isinstance and issubclass themselves.
# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])





Incompatible changes
In some situations, some exceptions will not be raised as expected.
If a metaclass implements the __or__ operator, it will override this:
>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]




Objections and responses
For more details about discussions, see links below:

Discussion in python-ideas
Discussion in typing-sig


1. Add a new operator for Union[type1, type2]?
PROS:

This syntax can be more readable, and is similar to other languages (Scala, …)
At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typing

CONS:

Adding this operator introduces a dependency between typing and builtins
Breaks the backport (in that typing can easily be backported but core types can’t)
If Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)



2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
PEP 563 (Postponed Evaluation of Annotations) is enough to accept this proposition,
if we accept to not be compatible with the dynamic evaluation of annotations (eval()).
>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'




3. Extend isinstance() and issubclass() to accept Union ?
isinstance(x, str | int) ==> "is x an instance of str or int"


PROS:

If they were permitted, then instance checking could use an extremely clean-looking notation

CONS:

Must migrate all of the typing module in builtin




Reference Implementation
A new built-in Union type must be implemented to hold the return
value of t1 | t2, and it must be supported by isinstance() and
issubclass(). This type can be placed in the types module.
Interoperability between types.Union and typing.Union must be
provided.
Once the Python language is extended, mypy [1] and other type checkers will
need to be updated to accept this new syntax.

A proposed implementation for cpython is here.
A proposed implementation for mypy is here.



References


[1] (1, 2) 
mypy
http://mypy-lang.org/

[2]
Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.html

[3]
Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5



Copyright
This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.



Source: https://github.com/python/peps/blob/main/peps/pep-0604.rst
Last modified: 2024-02-16 17:06:07 GMT


Contents

Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright


Page Source (GitHub)










PEP 604 – Allow writing union types as X | Y | peps.python.org


















PEP 604 – Allow writing union types as X | Y | peps.python.org:target { scroll-margin-top: 176px; }


Following system colour scheme






Selected dark colour scheme






Selected light colour scheme
















Python Enhancement Proposals

Python » 
PEP Index » 
PEP 604





Toggle light / dark / auto colour theme




PEP 604 – Allow writing union types as X | Y

Author:
Philippe PRADOS <python at prados.fr>, Maggie Moss <maggiebmoss at gmail.com>
Sponsor:
Chris Angelico <rosuav at gmail.com>
BDFL-Delegate:
Guido van Rossum <guido at python.org>
Discussions-To:
Typing-SIG list
Status:
Final
Type:
Standards Track
Topic:
Typing
Created:
28-Aug-2019
Python-Version:
3.10
Post-History:
28-Aug-2019, 05-Aug-2020



Table of Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright



Important
This PEP is a historical document. The up-to-date, canonical documentation can now be found at Union Type.
×
See PEP 1 for how to propose changes.


Abstract
This PEP proposes overloading the | operator on types to allow
writing Union[X, Y] as X | Y, and allows it to appear in
isinstance and issubclass calls.


Motivation
PEP 484 and PEP 526 propose a generic syntax to add typing to variables,
parameters and function returns. PEP 585 proposes to expose
parameters to generics at runtime.
Mypy [1] accepts a syntax which looks like:
annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']



To describe a disjunction (union type), the user must use Union[X, Y].

The verbosity of this syntax does not help with type adoption.


Proposal
Inspired by Scala [2] and Pike [3], this proposal adds operator
type.__or__().  With this new operator, it is possible to write
int | str instead of Union[int, str]. In addition to
annotations, the result of this expression would then be valid in
isinstance() and issubclass():
isinstance(5, int | str)
issubclass(bool, int | float)


We will also be able to write t | None or None | t instead of
Optional[t]:
isinstance(None, int | None)
isinstance(42, None | int)




Specification
The new union syntax should be accepted for function, variable and parameter annotations.

Simplified Syntax
# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]


The existing typing.Union and | syntax should be equivalent.
int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int


The order of the items in the Union should not matter for equality.
(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]


Optional values should be equivalent to the new union syntax
None | t == typing.Optional[t]


A new Union.__repr__() method should be implemented.
str(int | list[str])
# int | list[str]

str(int | int)
# int




isinstance and issubclass
The new syntax should be accepted for calls to isinstance and issubclass as long as the Union items are valid arguments to isinstance and issubclass themselves.
# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])





Incompatible changes
In some situations, some exceptions will not be raised as expected.
If a metaclass implements the __or__ operator, it will override this:
>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]




Objections and responses
For more details about discussions, see links below:

Discussion in python-ideas
Discussion in typing-sig


1. Add a new operator for Union[type1, type2]?
PROS:

This syntax can be more readable, and is similar to other languages (Scala, …)
At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typing

CONS:

Adding this operator introduces a dependency between typing and builtins
Breaks the backport (in that typing can easily be backported but core types can’t)
If Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)



2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
PEP 563 (Postponed Evaluation of Annotations) is enough to accept this proposition,
if we accept to not be compatible with the dynamic evaluation of annotations (eval()).
>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'




3. Extend isinstance() and issubclass() to accept Union ?
isinstance(x, str | int) ==> "is x an instance of str or int"


PROS:

If they were permitted, then instance checking could use an extremely clean-looking notation

CONS:

Must migrate all of the typing module in builtin




Reference Implementation
A new built-in Union type must be implemented to hold the return
value of t1 | t2, and it must be supported by isinstance() and
issubclass(). This type can be placed in the types module.
Interoperability between types.Union and typing.Union must be
provided.
Once the Python language is extended, mypy [1] and other type checkers will
need to be updated to accept this new syntax.

A proposed implementation for cpython is here.
A proposed implementation for mypy is here.



References


[1] (1, 2) 
mypy
http://mypy-lang.org/

[2]
Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.html

[3]
Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5



Copyright
This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.



Source: https://github.com/python/peps/blob/main/peps/pep-0604.rst
Last modified: 2024-02-16 17:06:07 GMT


Contents

Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright


Page Source (GitHub)








Following system colour scheme






Selected dark colour scheme






Selected light colour scheme













Following system colour scheme




Following system colour scheme



Selected dark colour scheme




Selected dark colour scheme



Selected light colour scheme











Selected light colour scheme











        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    

Python Enhancement Proposals

Python » 
PEP Index » 
PEP 604





Toggle light / dark / auto colour theme




PEP 604 – Allow writing union types as X | Y

Author:
Philippe PRADOS <python at prados.fr>, Maggie Moss <maggiebmoss at gmail.com>
Sponsor:
Chris Angelico <rosuav at gmail.com>
BDFL-Delegate:
Guido van Rossum <guido at python.org>
Discussions-To:
Typing-SIG list
Status:
Final
Type:
Standards Track
Topic:
Typing
Created:
28-Aug-2019
Python-Version:
3.10
Post-History:
28-Aug-2019, 05-Aug-2020



Table of Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright



Important
This PEP is a historical document. The up-to-date, canonical documentation can now be found at Union Type.
×
See PEP 1 for how to propose changes.


Abstract
This PEP proposes overloading the | operator on types to allow
writing Union[X, Y] as X | Y, and allows it to appear in
isinstance and issubclass calls.


Motivation
PEP 484 and PEP 526 propose a generic syntax to add typing to variables,
parameters and function returns. PEP 585 proposes to expose
parameters to generics at runtime.
Mypy [1] accepts a syntax which looks like:
annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']



To describe a disjunction (union type), the user must use Union[X, Y].

The verbosity of this syntax does not help with type adoption.


Proposal
Inspired by Scala [2] and Pike [3], this proposal adds operator
type.__or__().  With this new operator, it is possible to write
int | str instead of Union[int, str]. In addition to
annotations, the result of this expression would then be valid in
isinstance() and issubclass():
isinstance(5, int | str)
issubclass(bool, int | float)


We will also be able to write t | None or None | t instead of
Optional[t]:
isinstance(None, int | None)
isinstance(42, None | int)




Specification
The new union syntax should be accepted for function, variable and parameter annotations.

Simplified Syntax
# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]


The existing typing.Union and | syntax should be equivalent.
int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int


The order of the items in the Union should not matter for equality.
(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]


Optional values should be equivalent to the new union syntax
None | t == typing.Optional[t]


A new Union.__repr__() method should be implemented.
str(int | list[str])
# int | list[str]

str(int | int)
# int




isinstance and issubclass
The new syntax should be accepted for calls to isinstance and issubclass as long as the Union items are valid arguments to isinstance and issubclass themselves.
# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])





Incompatible changes
In some situations, some exceptions will not be raised as expected.
If a metaclass implements the __or__ operator, it will override this:
>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]




Objections and responses
For more details about discussions, see links below:

Discussion in python-ideas
Discussion in typing-sig


1. Add a new operator for Union[type1, type2]?
PROS:

This syntax can be more readable, and is similar to other languages (Scala, …)
At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typing

CONS:

Adding this operator introduces a dependency between typing and builtins
Breaks the backport (in that typing can easily be backported but core types can’t)
If Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)



2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
PEP 563 (Postponed Evaluation of Annotations) is enough to accept this proposition,
if we accept to not be compatible with the dynamic evaluation of annotations (eval()).
>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'




3. Extend isinstance() and issubclass() to accept Union ?
isinstance(x, str | int) ==> "is x an instance of str or int"


PROS:

If they were permitted, then instance checking could use an extremely clean-looking notation

CONS:

Must migrate all of the typing module in builtin




Reference Implementation
A new built-in Union type must be implemented to hold the return
value of t1 | t2, and it must be supported by isinstance() and
issubclass(). This type can be placed in the types module.
Interoperability between types.Union and typing.Union must be
provided.
Once the Python language is extended, mypy [1] and other type checkers will
need to be updated to accept this new syntax.

A proposed implementation for cpython is here.
A proposed implementation for mypy is here.



References


[1] (1, 2) 
mypy
http://mypy-lang.org/

[2]
Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.html

[3]
Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5



Copyright
This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.



Source: https://github.com/python/peps/blob/main/peps/pep-0604.rst
Last modified: 2024-02-16 17:06:07 GMT


Contents

Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright


Page Source (GitHub)


Python Enhancement Proposals

Python » 
PEP Index » 
PEP 604





Toggle light / dark / auto colour theme

Python Enhancement Proposals
Python » 
PEP Index » 
PEP 604
Python » PythonPEP Index » PEP IndexPEP 604



Toggle light / dark / auto colour theme
Toggle light / dark / auto colour theme

PEP 604 – Allow writing union types as X | Y

Author:
Philippe PRADOS <python at prados.fr>, Maggie Moss <maggiebmoss at gmail.com>
Sponsor:
Chris Angelico <rosuav at gmail.com>
BDFL-Delegate:
Guido van Rossum <guido at python.org>
Discussions-To:
Typing-SIG list
Status:
Final
Type:
Standards Track
Topic:
Typing
Created:
28-Aug-2019
Python-Version:
3.10
Post-History:
28-Aug-2019, 05-Aug-2020



Table of Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright



Important
This PEP is a historical document. The up-to-date, canonical documentation can now be found at Union Type.
×
See PEP 1 for how to propose changes.


Abstract
This PEP proposes overloading the | operator on types to allow
writing Union[X, Y] as X | Y, and allows it to appear in
isinstance and issubclass calls.


Motivation
PEP 484 and PEP 526 propose a generic syntax to add typing to variables,
parameters and function returns. PEP 585 proposes to expose
parameters to generics at runtime.
Mypy [1] accepts a syntax which looks like:
annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']



To describe a disjunction (union type), the user must use Union[X, Y].

The verbosity of this syntax does not help with type adoption.


Proposal
Inspired by Scala [2] and Pike [3], this proposal adds operator
type.__or__().  With this new operator, it is possible to write
int | str instead of Union[int, str]. In addition to
annotations, the result of this expression would then be valid in
isinstance() and issubclass():
isinstance(5, int | str)
issubclass(bool, int | float)


We will also be able to write t | None or None | t instead of
Optional[t]:
isinstance(None, int | None)
isinstance(42, None | int)




Specification
The new union syntax should be accepted for function, variable and parameter annotations.

Simplified Syntax
# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]


The existing typing.Union and | syntax should be equivalent.
int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int


The order of the items in the Union should not matter for equality.
(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]


Optional values should be equivalent to the new union syntax
None | t == typing.Optional[t]


A new Union.__repr__() method should be implemented.
str(int | list[str])
# int | list[str]

str(int | int)
# int




isinstance and issubclass
The new syntax should be accepted for calls to isinstance and issubclass as long as the Union items are valid arguments to isinstance and issubclass themselves.
# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])





Incompatible changes
In some situations, some exceptions will not be raised as expected.
If a metaclass implements the __or__ operator, it will override this:
>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]




Objections and responses
For more details about discussions, see links below:

Discussion in python-ideas
Discussion in typing-sig


1. Add a new operator for Union[type1, type2]?
PROS:

This syntax can be more readable, and is similar to other languages (Scala, …)
At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typing

CONS:

Adding this operator introduces a dependency between typing and builtins
Breaks the backport (in that typing can easily be backported but core types can’t)
If Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)



2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
PEP 563 (Postponed Evaluation of Annotations) is enough to accept this proposition,
if we accept to not be compatible with the dynamic evaluation of annotations (eval()).
>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'




3. Extend isinstance() and issubclass() to accept Union ?
isinstance(x, str | int) ==> "is x an instance of str or int"


PROS:

If they were permitted, then instance checking could use an extremely clean-looking notation

CONS:

Must migrate all of the typing module in builtin




Reference Implementation
A new built-in Union type must be implemented to hold the return
value of t1 | t2, and it must be supported by isinstance() and
issubclass(). This type can be placed in the types module.
Interoperability between types.Union and typing.Union must be
provided.
Once the Python language is extended, mypy [1] and other type checkers will
need to be updated to accept this new syntax.

A proposed implementation for cpython is here.
A proposed implementation for mypy is here.



References


[1] (1, 2) 
mypy
http://mypy-lang.org/

[2]
Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.html

[3]
Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5



Copyright
This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.



Source: https://github.com/python/peps/blob/main/peps/pep-0604.rst
Last modified: 2024-02-16 17:06:07 GMT

PEP 604 – Allow writing union types as X | Y

Author:
Philippe PRADOS <python at prados.fr>, Maggie Moss <maggiebmoss at gmail.com>
Sponsor:
Chris Angelico <rosuav at gmail.com>
BDFL-Delegate:
Guido van Rossum <guido at python.org>
Discussions-To:
Typing-SIG list
Status:
Final
Type:
Standards Track
Topic:
Typing
Created:
28-Aug-2019
Python-Version:
3.10
Post-History:
28-Aug-2019, 05-Aug-2020



Table of Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright



Important
This PEP is a historical document. The up-to-date, canonical documentation can now be found at Union Type.
×
See PEP 1 for how to propose changes.


Abstract
This PEP proposes overloading the | operator on types to allow
writing Union[X, Y] as X | Y, and allows it to appear in
isinstance and issubclass calls.


Motivation
PEP 484 and PEP 526 propose a generic syntax to add typing to variables,
parameters and function returns. PEP 585 proposes to expose
parameters to generics at runtime.
Mypy [1] accepts a syntax which looks like:
annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']



To describe a disjunction (union type), the user must use Union[X, Y].

The verbosity of this syntax does not help with type adoption.


Proposal
Inspired by Scala [2] and Pike [3], this proposal adds operator
type.__or__().  With this new operator, it is possible to write
int | str instead of Union[int, str]. In addition to
annotations, the result of this expression would then be valid in
isinstance() and issubclass():
isinstance(5, int | str)
issubclass(bool, int | float)


We will also be able to write t | None or None | t instead of
Optional[t]:
isinstance(None, int | None)
isinstance(42, None | int)




Specification
The new union syntax should be accepted for function, variable and parameter annotations.

Simplified Syntax
# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]


The existing typing.Union and | syntax should be equivalent.
int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int


The order of the items in the Union should not matter for equality.
(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]


Optional values should be equivalent to the new union syntax
None | t == typing.Optional[t]


A new Union.__repr__() method should be implemented.
str(int | list[str])
# int | list[str]

str(int | int)
# int




isinstance and issubclass
The new syntax should be accepted for calls to isinstance and issubclass as long as the Union items are valid arguments to isinstance and issubclass themselves.
# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])





Incompatible changes
In some situations, some exceptions will not be raised as expected.
If a metaclass implements the __or__ operator, it will override this:
>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]




Objections and responses
For more details about discussions, see links below:

Discussion in python-ideas
Discussion in typing-sig


1. Add a new operator for Union[type1, type2]?
PROS:

This syntax can be more readable, and is similar to other languages (Scala, …)
At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typing

CONS:

Adding this operator introduces a dependency between typing and builtins
Breaks the backport (in that typing can easily be backported but core types can’t)
If Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)



2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
PEP 563 (Postponed Evaluation of Annotations) is enough to accept this proposition,
if we accept to not be compatible with the dynamic evaluation of annotations (eval()).
>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'




3. Extend isinstance() and issubclass() to accept Union ?
isinstance(x, str | int) ==> "is x an instance of str or int"


PROS:

If they were permitted, then instance checking could use an extremely clean-looking notation

CONS:

Must migrate all of the typing module in builtin




Reference Implementation
A new built-in Union type must be implemented to hold the return
value of t1 | t2, and it must be supported by isinstance() and
issubclass(). This type can be placed in the types module.
Interoperability between types.Union and typing.Union must be
provided.
Once the Python language is extended, mypy [1] and other type checkers will
need to be updated to accept this new syntax.

A proposed implementation for cpython is here.
A proposed implementation for mypy is here.



References


[1] (1, 2) 
mypy
http://mypy-lang.org/

[2]
Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.html

[3]
Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5



Copyright
This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.

PEP 604 – Allow writing union types as X | YX | YX|Y
Author:
Philippe PRADOS <python at prados.fr>, Maggie Moss <maggiebmoss at gmail.com>
Sponsor:
Chris Angelico <rosuav at gmail.com>
BDFL-Delegate:
Guido van Rossum <guido at python.org>
Discussions-To:
Typing-SIG list
Status:
Final
Type:
Standards Track
Topic:
Typing
Created:
28-Aug-2019
Python-Version:
3.10
Post-History:
28-Aug-2019, 05-Aug-2020
Author::Philippe PRADOS <python at prados.fr>, Maggie Moss <maggiebmoss at gmail.com>Sponsor::Chris Angelico <rosuav at gmail.com>BDFL-Delegate::Guido van Rossum <guido at python.org>Discussions-To::Typing-SIG listTyping-SIG listStatus::FinalFinalType::Standards TrackStandards TrackTopic::TypingTypingCreated::28-Aug-2019Python-Version::3.10Post-History::28-Aug-2019, 05-Aug-2020
Table of Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright

Table of Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright

Table of Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright
AbstractAbstractMotivationMotivationProposalProposalSpecification
Simplified Syntax
isinstance and issubclass

Specification
Simplified Syntax
isinstance and issubclass
Simplified SyntaxSimplified Syntaxisinstance and issubclassisinstance and issubclassIncompatible changesIncompatible changesObjections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?

Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?
1. Add a new operator for Union[type1, type2]?1. Add a new operator for Union[type1, type2]?Union[type1, type2]Union[type1,type2]2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?type1 | type2type1|type23. Extend isinstance() and issubclass() to accept Union ?3. Extend isinstance() and issubclass() to accept Union ?isinstance()isinstance()issubclass()issubclass()UnionUnionReference ImplementationReference ImplementationReferencesReferencesCopyrightCopyright
Important
This PEP is a historical document. The up-to-date, canonical documentation can now be found at Union Type.
×
See PEP 1 for how to propose changes.
ImportantThis PEP is a historical document. The up-to-date, canonical documentation can now be found at Union Type.Union TypeUnion Type×See PEP 1 for how to propose changes.PEP 1
Abstract
This PEP proposes overloading the | operator on types to allow
writing Union[X, Y] as X | Y, and allows it to appear in
isinstance and issubclass calls.
AbstractAbstractThis PEP proposes overloading the | operator on types to allow
writing Union[X, Y] as X | Y, and allows it to appear in
isinstance and issubclass calls.||Union[X, Y]Union[X,Y]X | YX|Yisinstanceisinstanceissubclassissubclass
Motivation
PEP 484 and PEP 526 propose a generic syntax to add typing to variables,
parameters and function returns. PEP 585 proposes to expose
parameters to generics at runtime.
Mypy [1] accepts a syntax which looks like:
annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']



To describe a disjunction (union type), the user must use Union[X, Y].

The verbosity of this syntax does not help with type adoption.
MotivationMotivationPEP 484 and PEP 526 propose a generic syntax to add typing to variables,
parameters and function returns. PEP 585 proposes to expose
parameters to generics at runtime.
Mypy [1] accepts a syntax which looks like:PEP 484PEP 526PEP 585expose
parameters to generics at runtime[1]annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']

annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']
annotation: name_type
name_type: NAME (args)?
args: '[' paramslist ']'
paramslist: annotation (',' annotation)* [',']

To describe a disjunction (union type), the user must use Union[X, Y].
To describe a disjunction (union type), the user must use Union[X, Y].Union[X, Y]Union[X,Y]The verbosity of this syntax does not help with type adoption.
Proposal
Inspired by Scala [2] and Pike [3], this proposal adds operator
type.__or__().  With this new operator, it is possible to write
int | str instead of Union[int, str]. In addition to
annotations, the result of this expression would then be valid in
isinstance() and issubclass():
isinstance(5, int | str)
issubclass(bool, int | float)


We will also be able to write t | None or None | t instead of
Optional[t]:
isinstance(None, int | None)
isinstance(42, None | int)


ProposalProposalInspired by Scala [2] and Pike [3], this proposal adds operator
type.__or__().  With this new operator, it is possible to write
int | str instead of Union[int, str]. In addition to
annotations, the result of this expression would then be valid in
isinstance() and issubclass():[2][3]type.__or__()type.__or__()int | strint|strUnion[int, str]Union[int,str]isinstance()isinstance()issubclass()issubclass()isinstance(5, int | str)
issubclass(bool, int | float)

isinstance(5, int | str)
issubclass(bool, int | float)
isinstance(5, int | str)
issubclass(bool, int | float)
isinstance(5,int|str)issubclass(bool,int|float)We will also be able to write t | None or None | t instead of
Optional[t]:t | Nonet|NoneNone | tNone|tOptional[t]Optional[t]isinstance(None, int | None)
isinstance(42, None | int)

isinstance(None, int | None)
isinstance(42, None | int)
isinstance(None, int | None)
isinstance(42, None | int)
isinstance(None,int|None)isinstance(42,None|int)
Specification
The new union syntax should be accepted for function, variable and parameter annotations.

Simplified Syntax
# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]


The existing typing.Union and | syntax should be equivalent.
int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int


The order of the items in the Union should not matter for equality.
(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]


Optional values should be equivalent to the new union syntax
None | t == typing.Optional[t]


A new Union.__repr__() method should be implemented.
str(int | list[str])
# int | list[str]

str(int | int)
# int




isinstance and issubclass
The new syntax should be accepted for calls to isinstance and issubclass as long as the Union items are valid arguments to isinstance and issubclass themselves.
# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])



SpecificationSpecificationThe new union syntax should be accepted for function, variable and parameter annotations.
Simplified Syntax
# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]


The existing typing.Union and | syntax should be equivalent.
int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int


The order of the items in the Union should not matter for equality.
(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]


Optional values should be equivalent to the new union syntax
None | t == typing.Optional[t]


A new Union.__repr__() method should be implemented.
str(int | list[str])
# int | list[str]

str(int | int)
# int


Simplified SyntaxSimplified Syntax# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]

# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]
# Instead of
# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
def f(list: List[int | str], param: int | None) -> float | str:
    pass

f([1, "abc"], None)

# Instead of typing.List[typing.Union[str, int]]
typing.List[str | int]
list[str | int]

# Instead of typing.Dict[str, typing.Union[int, float]]
typing.Dict[str, int | float]
dict[str, int | float]
# Instead of# def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]def f(list:List[int|str],param:int|None)->float|str:passf([1,"abc"],None)# Instead of typing.List[typing.Union[str, int]]typing.List[str|int]list[str|int]# Instead of typing.Dict[str, typing.Union[int, float]]typing.Dict[str,int|float]dict[str,int|float]The existing typing.Union and | syntax should be equivalent.typing.Uniontyping.Union||int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int

int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int
int | str == typing.Union[int, str]

typing.Union[int, int] == int
int | int == int
int|str==typing.Union[int,str]typing.Union[int,int]==intint|int==intThe order of the items in the Union should not matter for equality.(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]

(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]
(int | str) == (str | int)
(int | str | float) == typing.Union[str, float, int]
(int|str)==(str|int)(int|str|float)==typing.Union[str,float,int]Optional values should be equivalent to the new union syntaxNone | t == typing.Optional[t]

None | t == typing.Optional[t]
None | t == typing.Optional[t]
None|t==typing.Optional[t]A new Union.__repr__() method should be implemented.str(int | list[str])
# int | list[str]

str(int | int)
# int

str(int | list[str])
# int | list[str]

str(int | int)
# int
str(int | list[str])
# int | list[str]

str(int | int)
# int
str(int|list[str])# int | list[str]str(int|int)# int
isinstance and issubclass
The new syntax should be accepted for calls to isinstance and issubclass as long as the Union items are valid arguments to isinstance and issubclass themselves.
# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])


isinstance and issubclassisinstance and issubclassThe new syntax should be accepted for calls to isinstance and issubclass as long as the Union items are valid arguments to isinstance and issubclass themselves.isinstanceisinstanceissubclassissubclassisinstanceisinstanceissubclassissubclass# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])

# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])
# valid
isinstance("", int | str)

# invalid
isinstance(2, list[int]) # TypeError: isinstance() argument 2 cannot be a parameterized generic
isinstance(1, int | list[int])

# valid
issubclass(bool, int | float)

# invalid
issubclass(bool, bool | list[int])
# validisinstance("",int|str)# invalidisinstance(2,list[int])# TypeError: isinstance() argument 2 cannot be a parameterized genericisinstance(1,int|list[int])# validissubclass(bool,int|float)# invalidissubclass(bool,bool|list[int])
Incompatible changes
In some situations, some exceptions will not be raised as expected.
If a metaclass implements the __or__ operator, it will override this:
>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]


Incompatible changesIncompatible changesIn some situations, some exceptions will not be raised as expected.If a metaclass implements the __or__ operator, it will override this:__or____or__>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]

>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]
>>> class M(type):
...     def __or__(self, other): return "Hello"
...
>>> class C(metaclass=M): pass
...
>>> C | int
'Hello'
>>> int | C
typing.Union[int, __main__.C]
>>> Union[C, int]
typing.Union[__main__.C, int]
>>> class M(type):... def __or__(self,other):return"Hello"...>>> class C(metaclass=M):pass...>>> C|int'Hello'>>> int|Ctyping.Union[int, __main__.C]>>> Union[C,int]typing.Union[__main__.C, int]
Objections and responses
For more details about discussions, see links below:

Discussion in python-ideas
Discussion in typing-sig


1. Add a new operator for Union[type1, type2]?
PROS:

This syntax can be more readable, and is similar to other languages (Scala, …)
At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typing

CONS:

Adding this operator introduces a dependency between typing and builtins
Breaks the backport (in that typing can easily be backported but core types can’t)
If Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)



2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
PEP 563 (Postponed Evaluation of Annotations) is enough to accept this proposition,
if we accept to not be compatible with the dynamic evaluation of annotations (eval()).
>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'




3. Extend isinstance() and issubclass() to accept Union ?
isinstance(x, str | int) ==> "is x an instance of str or int"


PROS:

If they were permitted, then instance checking could use an extremely clean-looking notation

CONS:

Must migrate all of the typing module in builtin


Objections and responsesObjections and responsesFor more details about discussions, see links below:
Discussion in python-ideas
Discussion in typing-sig
Discussion in python-ideasDiscussion in python-ideasDiscussion in typing-sigDiscussion in typing-sig
1. Add a new operator for Union[type1, type2]?
PROS:

This syntax can be more readable, and is similar to other languages (Scala, …)
At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typing

CONS:

Adding this operator introduces a dependency between typing and builtins
Breaks the backport (in that typing can easily be backported but core types can’t)
If Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)

1. Add a new operator for Union[type1, type2]?1. Add a new operator for Union[type1, type2]?Union[type1, type2]Union[type1,type2]PROS:
This syntax can be more readable, and is similar to other languages (Scala, …)
At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typing
This syntax can be more readable, and is similar to other languages (Scala, …)At runtime, int|str might return a simple object in 3.10, rather than everything that
you’d need to grab from importing typingint|strint|strtypingtypingCONS:
Adding this operator introduces a dependency between typing and builtins
Breaks the backport (in that typing can easily be backported but core types can’t)
If Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)
Adding this operator introduces a dependency between typing and builtinstypingtypingbuiltinsbuiltinsBreaks the backport (in that typing can easily be backported but core types can’t)typingtypingtypestypesIf Python itself doesn’t have to be changed, we’d still need to implement it in mypy, Pyre, PyCharm,
Pytype, and who knows what else (it’s a minor change see “Reference Implementation”)
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
PEP 563 (Postponed Evaluation of Annotations) is enough to accept this proposition,
if we accept to not be compatible with the dynamic evaluation of annotations (eval()).
>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'


2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?type1 | type2type1|type2PEP 563 (Postponed Evaluation of Annotations) is enough to accept this proposition,
if we accept to not be compatible with the dynamic evaluation of annotations (eval()).PEP 563eval()eval()>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'

>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'
>>> from __future__ import annotations
>>> def foo() -> int | str: pass
...
>>> eval(foo.__annotations__['return'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1, in <module>
TypeError: unsupported operand type(s) for |: 'type' and 'type'
>>> from __future__ importannotations>>> def foo()->int|str:pass...>>> eval(foo.__annotations__['return'])Traceback (most recent call last):"<stdin>"1<module>"<string>"1<module>TypeErrorunsupported operand type(s) for |: 'type' and 'type'
3. Extend isinstance() and issubclass() to accept Union ?
isinstance(x, str | int) ==> "is x an instance of str or int"


PROS:

If they were permitted, then instance checking could use an extremely clean-looking notation

CONS:

Must migrate all of the typing module in builtin

3. Extend isinstance() and issubclass() to accept Union ?3. Extend isinstance() and issubclass() to accept Union ?isinstance()isinstance()issubclass()issubclass()UnionUnionisinstance(x, str | int) ==> "is x an instance of str or int"

isinstance(x, str | int) ==> "is x an instance of str or int"
isinstance(x, str | int) ==> "is x an instance of str or int"
isinstance(x,str|int)==>"is x an instance of str or int"PROS:
If they were permitted, then instance checking could use an extremely clean-looking notation
If they were permitted, then instance checking could use an extremely clean-looking notationCONS:
Must migrate all of the typing module in builtin
Must migrate all of the typing module in builtintypingtypingbuiltinbuiltin
Reference Implementation
A new built-in Union type must be implemented to hold the return
value of t1 | t2, and it must be supported by isinstance() and
issubclass(). This type can be placed in the types module.
Interoperability between types.Union and typing.Union must be
provided.
Once the Python language is extended, mypy [1] and other type checkers will
need to be updated to accept this new syntax.

A proposed implementation for cpython is here.
A proposed implementation for mypy is here.

Reference ImplementationReference ImplementationA new built-in Union type must be implemented to hold the return
value of t1 | t2, and it must be supported by isinstance() and
issubclass(). This type can be placed in the types module.
Interoperability between types.Union and typing.Union must be
provided.UnionUniont1 | t2t1|t2isinstance()isinstance()issubclass()issubclass()typestypestypes.Uniontypes.Uniontyping.Uniontyping.UnionOnce the Python language is extended, mypy [1] and other type checkers will
need to be updated to accept this new syntax.[1]
A proposed implementation for cpython is here.
A proposed implementation for mypy is here.
A proposed implementation for cpython is here.cpython is hereA proposed implementation for mypy is here.mypy is here
References


[1] (1, 2) 
mypy
http://mypy-lang.org/

[2]
Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.html

[3]
Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5

ReferencesReferences

[1] (1, 2) 
mypy
http://mypy-lang.org/

[2]
Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.html

[3]
Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5

[1] (1, 2) 
mypy
http://mypy-lang.org/[1] (1, 2)  (1, 2) 12mypy
http://mypy-lang.org/http://mypy-lang.org/
[2]
Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.html[2]2Scala Union Types
https://dotty.epfl.ch/docs/reference/new-types/union-types.htmlhttps://dotty.epfl.ch/docs/reference/new-types/union-types.html
[3]
Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5[3]3Pike
http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5http://pike.lysator.liu.se/docs/man/chapter_3.html#3.5
Copyright
This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.
CopyrightCopyrightThis document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.Source: https://github.com/python/peps/blob/main/peps/pep-0604.rsthttps://github.com/python/peps/blob/main/peps/pep-0604.rstLast modified: 2024-02-16 17:06:07 GMT2024-02-16 17:06:07 GMT
Contents

Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright


Page Source (GitHub)
Contents
Abstract
Motivation
Proposal
Specification
Simplified Syntax
isinstance and issubclass


Incompatible changes
Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?


Reference Implementation
References
Copyright
AbstractAbstractMotivationMotivationProposalProposalSpecification
Simplified Syntax
isinstance and issubclass

Specification
Simplified Syntax
isinstance and issubclass
Simplified SyntaxSimplified Syntaxisinstance and issubclassisinstance and issubclassIncompatible changesIncompatible changesObjections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?

Objections and responses
1. Add a new operator for Union[type1, type2]?
2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?
3. Extend isinstance() and issubclass() to accept Union ?
1. Add a new operator for Union[type1, type2]?1. Add a new operator for Union[type1, type2]?Union[type1, type2]Union[type1,type2]2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?2. Change only PEP 484 (Type hints) to accept the syntax type1 | type2 ?type1 | type2type1|type23. Extend isinstance() and issubclass() to accept Union ?3. Extend isinstance() and issubclass() to accept Union ?isinstance()isinstance()issubclass()issubclass()UnionUnionReference ImplementationReference ImplementationReferencesReferencesCopyrightCopyrightPage Source (GitHub)